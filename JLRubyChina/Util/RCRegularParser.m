//
//  SMRegularParser.m
//  SinaMBlog
//
//  Created by jimneylee on 13-2-18.
//  Copyright (c) 2013年 jimneylee. All rights reserved.
//

#import "RCRegularParser.h"
#import "NSStringAdditions.h"
#import "RCKeywordEntity.h"

static NSString* atRegular = @"@[^.,:;!?()\\s#@。，：；！？（）]+";
static NSString* sharpRegular = @"#(.*?)楼";//TODO:digit regular
static NSString* emojiRegular = @"\\[([\u4e00-\u9fa5]+)\\]";
//http://stackoverflow.com/questions/16710554/c-sharp-regex-parse-to-pull-photos-from-markdown
static NSString* imageRegular = @"!\\[.*?\\]\()\\(.*?\\)";

@implementation RCRegularParser

+ (NSArray *)keywordRangesOfAtPersonInString:(NSString *)string {
    NSError *error;
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:atRegular
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    __block NSMutableArray *rangesArray = [NSMutableArray array];
    __block NSString* keyword = nil;
    __block RCKeywordEntity* keywordEntity = nil;
    [regex enumerateMatchesInString:string
                            options:0
                              range:NSMakeRange(0, string.length)
                         usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
                             NSRange resultRange = [result range];
                             // range & name
                             keyword = [regex replacementStringForResult:result
                                                                        inString:string
                                                                          offset:0
                                                                        template:@"$0"];
                             if (keyword.length) {
                                 // @someone
                                 keyword = [keyword substringWithRange:NSMakeRange(1, keyword.length-1)];
                                 keywordEntity = [[RCKeywordEntity alloc] init];
                                 keywordEntity.keyword = keyword;
                                 keywordEntity.range = resultRange;
                                 [rangesArray addObject:keywordEntity];
                             }
                         }];
    return rangesArray;
}

+ (NSArray *)keywordRangesOfSharpFloorInString:(NSString *)string {
    NSError *error;
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:sharpRegular
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    __block NSMutableArray *rangesArray = [NSMutableArray array];
    __block NSString* keyword = nil;
    __block RCKeywordEntity* keywordEntity = nil;
    [regex enumerateMatchesInString:string
                            options:0
                              range:NSMakeRange(0, string.length)
                         usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
                             NSRange resultRange = [result range];
                             // range & trend
                             keyword = [regex replacementStringForResult:result
                                                                inString:string
                                                                  offset:0
                                                                template:@"$0"];
                             if (keyword.length) {
                                 // #sometrend#
                                 keyword = [keyword substringWithRange:NSMakeRange(1, keyword.length-2)];
                                 keywordEntity = [[RCKeywordEntity alloc] init];
                                 keywordEntity.keyword = keyword;
                                 keywordEntity.range = resultRange;
                                 [rangesArray addObject:keywordEntity];
                             }
                         }];
    return rangesArray;
}

+ (NSArray *)keywordRangesOfEmotionInString:(NSString *)string trimedString:(NSString **)trimedString {
    NSError *error;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:emojiRegular
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    __block NSMutableArray *rangesArray = [NSMutableArray array];
    __block NSMutableString *mutableString = [string mutableCopy];
    __block NSInteger offset = 0;
    __block NSString* keyword = nil;
    __block RCKeywordEntity* keywordEntity = nil;
    [regex enumerateMatchesInString:string
                            options:0
                              range:NSMakeRange(0, string.length)
                         usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
                             NSRange resultRange = [result range];
                             resultRange.location += offset;
                             // range & emotion
                             keyword = [regex replacementStringForResult:result
                                                                inString:mutableString
                                                                  offset:offset
                                                                template:@"$0"];
                             keywordEntity = [[RCKeywordEntity alloc] init];
                             keywordEntity.keyword = keyword;
                             keywordEntity.range = resultRange;
                             [rangesArray addObject:keywordEntity];
                             [mutableString replaceCharactersInRange:resultRange withString:@""];
                             offset -= resultRange.length;
                             
                             *trimedString = mutableString;
                         }];
    return rangesArray;
}

+ (NSArray *)imageUrlsInString:(NSString *)string trimedString:(NSString **)trimedString {
    NSError *error;
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:imageRegular
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    __block NSMutableArray *imagesArray = [NSMutableArray array];
    __block NSMutableString *mutableString = [string mutableCopy];
    __block NSInteger offset = 0;
    __block NSString *keyword = nil;
    __block NSString *imageUrl = nil;
    [regex enumerateMatchesInString:string
                            options:0
                              range:NSMakeRange(0, string.length)
                         usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
                             NSRange resultRange = [result range];
                             resultRange.location += offset;
                             // image
                             keyword = [regex replacementStringForResult:result
                                                                inString:mutableString
                                                                  offset:offset
                                                                template:@"$0"];
                             NSRange startRange = [keyword rangeOfString:@"]("];
                             if (startRange.length > 0) {
                                 NSRange range = NSMakeRange(startRange.location + startRange.length,
                                                             keyword.length - (startRange.location + startRange.length + 1));
                                 imageUrl = [keyword substringWithRange:range];
                                 [imagesArray addObject:imageUrl];
                             }
                             
                             [mutableString replaceCharactersInRange:resultRange withString:@""];
                             offset -= resultRange.length;
                             
                             *trimedString = mutableString;
                         }];
    return imagesArray;
}

@end
